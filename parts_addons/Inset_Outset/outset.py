import bpy
import bmesh
import mathutils
from mathutils import Vector


class MESH_OT_outset_cl(bpy.types.Operator):
    """Select a face in edit mode"""

    bl_idname = "mesh.outset_clipper"
    bl_label = "Outset clipper"
    bl_options = {"REGISTER", "UNDO"}

    dikte: bpy.props.FloatProperty(
        name="dikte",
        default=0.4,
        subtype="DISTANCE",
    )  # type: ignore

    miter: bpy.props.FloatProperty(
        name="miter",
        default=1,
    )  # type: ignore

    arc_t: bpy.props.FloatProperty(name="Arc Tollerance", default=1, min=0, max=2)  # type: ignore
    corner_shape: bpy.props.EnumProperty(
        name="Corner Shape",
        items=[("JT_ROUND", "Round", ""), ("JT_SQUARE", "Square", ""), ("JT_MITER", "Miter", "")],
        default="JT_MITER",
        description="Shape of corners generated by offsetting",
    )  # type: ignore

    def draw(self, context):
        layout = self.layout
        layout.prop(self, "dikte", icon="BLANK1", text="With")
        layout.label(text="Corner Shape"),
        layout.prop(self, "corner_shape", text="", icon="BLANK1")
        if self.corner_shape == "JT_ROUND":
            layout.prop(self, "arc_t", icon="BLANK1")
        if self.corner_shape == "JT_MITER":
            layout.prop(self, "miter", icon="BLANK1")

    def execute(self, context):

        try:
            import pyclipper  # type: ignore
        except ImportError:
            self.report({"ERROR"}, "Please install dependencies in the Preferences panel.")
            return {"FINISHED"}

        factor = 100000000000000
        Z_richting = Vector((0, 0, 1))
        corner_shape = self.corner_shape
        arc_t = 1 / (self.arc_t + 0.001) * 10000000000
        # arc_t = self.arc_t/10000000000
        if self.dikte > 0:
            rand_breedte = self.dikte * factor
        else:
            bpy.ops.mesh.inset_clipper(dikte=self.dikte, corner_shape=corner_shape, arc_t=arc_t)
            return {"FINISHED"}

        miter = self.miter

        class Voorbereiden:

            # Een gekozen vlak tot een nieuw object maken om te bewerken
            def vlak_appart(self):
                geselecteerd = bpy.context.selected_objects
                actief_oud = bpy.context.active_object
                # bpy.ops.mesh.duplicate()
                bpy.ops.mesh.separate(type="SELECTED")

                bpy.ops.object.editmode_toggle()
                laatste = bpy.context.selected_objects[-1]
                bpy.ops.object.select_all(action="DESELECT")
                laatste.select_set(True)
                bpy.context.view_layer.objects.active = laatste
                bpy.ops.object.origin_set(type="ORIGIN_GEOMETRY", center="MEDIAN")
                ob = bpy.context.object
                pos_oud = ob.location.copy()
                ob.location = (0, 0, 0)
                return (pos_oud, actief_oud)

            # Het object wat gemaakt is(moet een vlak zijn ) plat leggen voor pyclipper
            def plat_leggen(self, ob):

                bpy.ops.object.mode_set(mode="EDIT")
                me = ob.data
                bm = bmesh.from_edit_mesh(me)
                bm.faces.ensure_lookup_table()
                f = bm.faces[0]
                normaal = f.normal
                bpy.context.scene["normaal_vlak"] = normaal
                verschil = normaal.rotation_difference(Z_richting)
                matrix_naar_xy = verschil.to_matrix().to_4x4()
                matrix_inv = matrix_naar_xy.inverted()
                for v in bm.verts:
                    v.co = v.co @ matrix_inv
                bpy.ops.mesh.select_all(action="SELECT")

                bpy.ops.mesh.normals_make_consistent(inside=False)

                return matrix_naar_xy

            # Het uiteindelijke bewerkte vlak weer terug draaien en toevoegen aan het oorspronkelijke object
            def terug_draaien(self, ob, matrix, pos_oud, moeder_object):
                me = ob.data
                bm = bmesh.from_edit_mesh(me)

                for v in bm.verts:
                    v.co = v.co @ matrix
                ob.location = pos_oud
                bpy.ops.object.editmode_toggle()
                moeder_object.select_set(True)
                bpy.context.view_layer.objects.active = moeder_object
                bpy.ops.object.join()
                bpy.ops.object.editmode_toggle()
                bpy.ops.mesh.select_all(action="SELECT")
                bpy.ops.mesh.remove_doubles()
                bpy.ops.mesh.select_all(action="DESELECT")
                bpy.ops.mesh.select_mode(type="FACE")

        def punten_volgorde(ob):
            # duplikaat maken waarvan alle binnen lijnen worden verwijderd om de omtrek te kunnen bepalen
            bpy.ops.mesh.region_to_loop()

            bpy.ops.mesh.duplicate()
            # bpy.ops.mesh.dissolve_limited()
            me = ob.data
            bm = bmesh.from_edit_mesh(me)
            bm.edges.ensure_lookup_table()
            for e in bm.edges:
                if e.select:
                    lijn = e
                    break

            eerste_punt = lijn.verts[0]
            doorgaan = True

            punt = eerste_punt
            punten_op_volgorde = [punt.co]

            while doorgaan:
                ander_punt = lijn.other_vert(punt)
                if ander_punt == eerste_punt:
                    break
                punten_op_volgorde.append(ander_punt.co)
                lijnen = ander_punt.link_edges
                if len(lijnen) > 2:
                    print("teveel knopen")
                    break

                if lijnen[0] == lijn:
                    lijn = lijnen[1]
                else:
                    lijn = lijnen[0]
                punt = ander_punt
            bpy.ops.mesh.delete()

            bm.free
            return punten_op_volgorde

        def punten_naar_2D(punten):
            punten_2d = []
            for v in punten:
                x = v[0] * factor
                y = v[1] * factor
                punt = (x, y)
                punten_2d.append(punt)
            punten_2d = tuple(punten_2d)
            return punten_2d

        def clipper_offset(punten_2d, rand_breedte):
            subj = punten_2d

            pco = pyclipper.PyclipperOffset()
            pco.MiterLimit = miter
            pco.ArcTolerance = arc_t
            # pc = pyclipper.Pyclipper()
            # pc.SetTolerance(10)
            jt = pyclipper.JT_ROUND

            if corner_shape == "JT_SQUARE":
                jt = pyclipper.JT_SQUARE
            elif corner_shape == "JT_MITER":
                jt = pyclipper.JT_MITER

            pco.AddPath(subj, jt, pyclipper.ET_CLOSEDPOLYGON)
            # JT_ROUND   CLOSEDPOLYGON
            # JT_SQUARE, JT_MITER
            solution = pco.Execute(rand_breedte)
            return solution

        def terug_naar_3d(oplossing):
            coord_3D = []
            for s in oplossing:
                naar_coord = []
                for w in s:
                    x = w[0] / factor
                    y = w[1] / factor
                    coord = Vector((x, y, 0))
                    naar_coord.append(coord)
                coord_3D.append(naar_coord)
            return coord_3D

        def mesh_maken(coord_3D, ob):
            me = ob.data
            bm = bmesh.from_edit_mesh(me)
            alle_vertices = []

            for blok in coord_3D:

                vertices = []
                for c in blok:
                    v = bm.verts.new(c)
                    vertices.append(v)
                    # v.select_set(True)
                    print(v)

                for e in range(1, len(vertices)):
                    v1 = vertices[e - 1]
                    v2 = vertices[e]
                    e = bm.edges.new((v1, v2))
                    e.select_set(True)
                bm.edges.new((v2, vertices[0]))
                bmesh.update_edit_mesh(ob.data, loop_triangles=True)
                alle_vertices = alle_vertices + vertices

            return (vertices, bm)

        ###############################################################
        ############  PROGRAMMA   #####################################
        ###############################################################

        voorbereiden = Voorbereiden()
        pos_oud, moeder_object = voorbereiden.vlak_appart()
        ob = bpy.context.object
        matrix = voorbereiden.plat_leggen(ob)

        ob = bpy.context.object

        coord_3D = punten_volgorde(ob)
        punten_2D = punten_naar_2D(coord_3D)

        bpy.ops.mesh.select_all(action="SELECT")
        bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={"value": (0, 0, 1), "orient_type": "NORMAL"})
        bpy.ops.mesh.select_linked()

        bpy.ops.transform.resize(value=(1, 1, 2), orient_type="GLOBAL")
        bpy.ops.mesh.select_all(action="DESELECT")

        offset_punten = clipper_offset(punten_2D, rand_breedte)
        coord_3D = terug_naar_3d(offset_punten)
        vertices, bm = mesh_maken(coord_3D, ob)
        bpy.ops.mesh.edge_face_add()

        bpy.ops.mesh.select_all(action="INVERT")
        bpy.ops.mesh.intersect_boolean(solver="FAST")
        ob = bpy.context.object
        voorbereiden.terug_draaien(ob, matrix, pos_oud, moeder_object)

        return {"FINISHED"}
